// Generated by ReScript, PLEASE EDIT WITH CARE

import * as SchemaParser from "./SchemaParser.res.mjs";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as Stdlib_Result from "rescript/lib/es6/Stdlib_Result.js";
import * as TypeGenerator from "./TypeGenerator.res.mjs";

function generateTypes(openApiJsonString) {
  return Stdlib_Result.flatMap(SchemaParser.parseFromJsonString(openApiJsonString), schemas => {
    TypeGenerator.clearExtractedEnums();
    let typeResults = schemas.map(namedSchema => Stdlib_Result.map(TypeGenerator.convertSchema(namedSchema), rescriptType => {
      let definition = TypeGenerator.generateTypeDefinition(namedSchema.name, rescriptType);
      return {
        name: namedSchema.name,
        definition: definition
      };
    }));
    let errors = Stdlib_Array.filterMap(typeResults, result => {
      if (result.TAG === "Ok") {
        return;
      } else {
        return result._0;
      }
    });
    if (errors.length > 0) {
      return {
        TAG: "Error",
        _0: "Type generation failed: " + errors.join(", ")
      };
    }
    let generatedTypes = Stdlib_Array.filterMap(typeResults, result => {
      if (result.TAG === "Ok") {
        return result._0;
      }
      
    });
    let extractedEnumDefinitions = TypeGenerator.generateExtractedEnumDefinitions();
    let enumTypes = extractedEnumDefinitions.map(definition => {
      let typeName = Stdlib_Option.getOr(definition.split(" ")[1], "Unknown");
      return {
        name: typeName,
        definition: definition
      };
    });
    return {
      TAG: "Ok",
      _0: enumTypes.concat(generatedTypes)
    };
  });
}

function generateModule(openApiJsonString) {
  return Stdlib_Result.map(generateTypes(openApiJsonString), types => {
    let typeDefinitions = types.map(param => param.definition).join("\n\n");
    return "// Generated ReScript types from OpenAPI specification\n\n" + typeDefinitions;
  });
}

function generateFromFile(_filePath) {
  return {
    TAG: "Error",
    _0: "File I/O not implemented yet - use generateModule with JSON string"
  };
}

export {
  generateTypes,
  generateModule,
  generateFromFile,
}
/* No side effect */
