// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/Js_dict.js";
import * as Js_json from "rescript/lib/es6/Js_json.js";
import * as JSONSchema7 from "rescript-json-schema/src/JSONSchema7.res.mjs";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function parseDocument(openApiDoc) {
  try {
    let parsedDoc = Js_json.decodeObject(openApiDoc);
    if (parsedDoc === undefined) {
      return {
        TAG: "Error",
        _0: "Invalid OpenAPI document: not an object"
      };
    }
    let componentsJson = Js_dict.get(parsedDoc, "components");
    if (componentsJson === undefined) {
      return {
        TAG: "Ok",
        _0: []
      };
    }
    let components = Js_json.decodeObject(componentsJson);
    if (components === undefined) {
      return {
        TAG: "Error",
        _0: "Invalid components section"
      };
    }
    let schemasJson = Js_dict.get(components, "schemas");
    if (schemasJson === undefined) {
      return {
        TAG: "Ok",
        _0: []
      };
    }
    let schemas = Js_json.decodeObject(schemasJson);
    if (schemas === undefined) {
      return {
        TAG: "Error",
        _0: "Invalid schemas section"
      };
    }
    let namedSchemas = Js_dict.entries(schemas).map(param => ({
      name: param[0],
      schema: param[1]
    }));
    return {
      TAG: "Ok",
      _0: namedSchemas
    };
  } catch (exn) {
    return {
      TAG: "Error",
      _0: "JSON parsing failed"
    };
  }
}

function parseFromJsonString(jsonString) {
  try {
    return parseDocument(JSON.parse(jsonString));
  } catch (exn) {
    return {
      TAG: "Error",
      _0: "Invalid JSON"
    };
  }
}

function filterObjectSchemas(schemas) {
  return schemas.filter(param => {
    let schema = param.schema;
    let typeArray = schema.type;
    if (typeArray === undefined) {
      return Stdlib_Option.isSome(schema.properties);
    }
    let types = JSONSchema7.Arrayable.classify(Primitive_option.valFromOption(typeArray));
    if (types.TAG === "Single") {
      return types._0 === "object";
    } else {
      return types._0.includes("object");
    }
  });
}

function filterEnumSchemas(schemas) {
  return schemas.filter(param => Stdlib_Option.isSome(param.schema.enum));
}

function extractReferences(schema) {
  let refs = [];
  let ref = schema.$ref;
  if (ref !== undefined) {
    refs.push(ref);
  }
  return refs;
}

export {
  parseDocument,
  parseFromJsonString,
  filterObjectSchemas,
  filterEnumSchemas,
  extractReferences,
}
/* No side effect */
