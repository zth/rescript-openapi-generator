// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/Js_dict.js";
import * as Js_json from "rescript/lib/es6/Js_json.js";
import * as JSONSchema7 from "rescript-json-schema/src/JSONSchema7.res.mjs";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as Stdlib_Result from "rescript/lib/es6/Stdlib_Result.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_string from "rescript/lib/es6/Primitive_string.js";

let extractedEnums = {
  contents: []
};

function toCamelCase(name) {
  return Stdlib_Option.getOr(name[0], "").toLowerCase() + name.slice(1);
}

function mapPrimitiveType(schemaType) {
  if (schemaType === "boolean") {
    return "Bool";
  } else if (schemaType === "string") {
    return "String";
  } else if (schemaType === "integer") {
    return "Int";
  } else if (schemaType === "number") {
    return "Float";
  } else {
    return "Unknown";
  }
}

function generateVariantNames(enumValues) {
  try {
    let variants = enumValues.map(value => {
      let str = Js_json.classify(value);
      if (typeof str !== "object") {
        return "Unknown";
      }
      if (str.TAG !== "JSONString") {
        return "Unknown";
      }
      let str$1 = str._0;
      let capitalized = str$1.split("-").map(part => {
        let firstChar = Stdlib_Option.getOr(part[0], "").toUpperCase();
        let rest = part.slice(1);
        return firstChar + rest;
      }).join("");
      return "@as(\"" + str$1 + "\") " + capitalized;
    });
    return {
      TAG: "Ok",
      _0: variants
    };
  } catch (exn) {
    return {
      TAG: "Error",
      _0: "Failed to parse enum values"
    };
  }
}

function generateVariantFromEnum(enumValues) {
  return Stdlib_Result.map(generateVariantNames(enumValues), variants => ({
    TAG: "Variant",
    _0: variants
  }));
}

function extractInlineEnum(baseName, propName, enumValues) {
  return Stdlib_Result.map(generateVariantNames(enumValues), variants => {
    let baseNameLower = Stdlib_Option.getOr(baseName[0], "").toLowerCase() + baseName.slice(1);
    let propNameCapitalized = Stdlib_Option.getOr(propName[0], "").toUpperCase() + propName.slice(1);
    let enumTypeName = baseNameLower + propNameCapitalized;
    let extractedEnum = {
      name: enumTypeName,
      variants: variants
    };
    extractedEnums.contents = extractedEnums.contents.concat([extractedEnum]);
    return enumTypeName;
  });
}

function convertPropertySchema(baseName, name, propSchema, isRequired) {
  let ref = propSchema.$ref;
  if (ref !== undefined) {
    let parts = ref.split("/");
    let typeName = Stdlib_Option.getOr(parts[parts.length - 1 | 0], "Unknown");
    let fieldType = {
      TAG: "Reference",
      _0: toCamelCase(typeName)
    };
    return {
      TAG: "Ok",
      _0: {
        name: name,
        type_: fieldType,
        required: isRequired
      }
    };
  }
  let enumValues = propSchema.enum;
  if (enumValues !== undefined) {
    return Stdlib_Result.map(extractInlineEnum(baseName, name, enumValues), enumTypeName => ({
      name: name,
      type_: {
        TAG: "Reference",
        _0: toCamelCase(enumTypeName)
      },
      required: isRequired
    }));
  }
  let typeArrayable = propSchema.type;
  if (typeArrayable === undefined) {
    return {
      TAG: "Error",
      _0: "Unsupported property schema for field: " + name
    };
  }
  let primitiveType = JSONSchema7.Arrayable.classify(Primitive_option.valFromOption(typeArrayable));
  if (primitiveType.TAG !== "Single") {
    return {
      TAG: "Error",
      _0: "Union types not supported yet"
    };
  }
  let primitiveType$1 = primitiveType._0;
  let baseType = mapPrimitiveType(primitiveType$1);
  let finalType;
  if (primitiveType$1 === "array") {
    let itemsArrayable = propSchema.items;
    if (itemsArrayable !== undefined) {
      let _itemSchema = JSONSchema7.Arrayable.classify(Primitive_option.valFromOption(itemsArrayable));
      finalType = _itemSchema.TAG === "Single" ? ({
          TAG: "Array",
          _0: "String"
        }) : "Unknown";
    } else {
      finalType = {
        TAG: "Array",
        _0: "Unknown"
      };
    }
  } else {
    finalType = baseType;
  }
  return {
    TAG: "Ok",
    _0: {
      name: name,
      type_: finalType,
      required: isRequired
    }
  };
}

function convertProperty(baseName, name, propDefinition, isRequired) {
  let propSchema = JSONSchema7.Definition.classify(propDefinition);
  if (propSchema.TAG === "Schema") {
    return convertPropertySchema(baseName, name, propSchema._0, isRequired);
  } else {
    return {
      TAG: "Error",
      _0: "Boolean schema definitions not supported"
    };
  }
}

function convertObjectSchema(baseName, schema, requiredFields) {
  let properties = schema.properties;
  if (properties === undefined) {
    return {
      TAG: "Error",
      _0: "Object schema has no properties"
    };
  }
  let propertyNames = Object.keys(properties);
  let fieldResults = propertyNames.map(propName => {
    let propSchema = Stdlib_Option.getOr(Js_dict.get(properties, propName), false);
    let isRequired = requiredFields.includes(propName);
    return convertProperty(baseName, propName, propSchema, isRequired);
  });
  let errors = Stdlib_Array.filterMap(fieldResults, result => {
    if (result.TAG === "Ok") {
      return;
    } else {
      return result._0;
    }
  });
  if (errors.length > 0) {
    return {
      TAG: "Error",
      _0: "Property conversion failed: " + errors.join(", ")
    };
  }
  let fields = Stdlib_Array.filterMap(fieldResults, result => {
    if (result.TAG === "Ok") {
      return result._0;
    }
    
  });
  return {
    TAG: "Ok",
    _0: {
      TAG: "Record",
      _0: fields
    }
  };
}

function convertSchema(namedSchema) {
  let schema = namedSchema.schema;
  let enumValues = schema.enum;
  if (enumValues !== undefined) {
    return generateVariantFromEnum(enumValues);
  }
  let typeArrayable = schema.type;
  if (typeArrayable !== undefined) {
    let primitiveType = JSONSchema7.Arrayable.classify(Primitive_option.valFromOption(typeArrayable));
    if (primitiveType.TAG !== "Single") {
      return {
        TAG: "Error",
        _0: "Union types not supported"
      };
    }
    let primitiveType$1 = primitiveType._0;
    if (primitiveType$1 !== "object") {
      return {
        TAG: "Ok",
        _0: mapPrimitiveType(primitiveType$1)
      };
    }
    let requiredFields = Stdlib_Option.getOr(schema.required, []);
    return convertObjectSchema(namedSchema.name, schema, requiredFields);
  }
  let match = schema.properties;
  if (match === undefined) {
    return {
      TAG: "Error",
      _0: "Schema has no type or properties"
    };
  }
  let requiredFields$1 = Stdlib_Option.getOr(schema.required, []);
  return convertObjectSchema(namedSchema.name, schema, requiredFields$1);
}

function generateExtractedEnumDefinitions() {
  return extractedEnums.contents.map(param => {
    let variantString = param.variants.join(" | ");
    return "type " + toCamelCase(param.name) + " = " + variantString;
  });
}

function clearExtractedEnums() {
  extractedEnums.contents = [];
}

function generateTypeDefinition(name, rescriptType) {
  let typeToString = type_ => {
    if (typeof type_ !== "object") {
      switch (type_) {
        case "String" :
          return "string";
        case "Int" :
          return "int";
        case "Float" :
          return "float";
        case "Bool" :
          return "bool";
        case "Unknown" :
          return "unknown";
      }
    } else {
      switch (type_.TAG) {
        case "Array" :
          return "array<" + typeToString(type_._0) + ">";
        case "Option" :
          return "option<" + typeToString(type_._0) + ">";
        case "Record" :
          let fields = type_._0;
          let requiredFields = fields.filter(field => field.required);
          let optionalFields = fields.filter(field => !field.required);
          let sortedOptionalFields = optionalFields.toSorted((a, b) => Primitive_string.compare(a.name, b.name));
          let sortedFields = requiredFields.concat(sortedOptionalFields);
          let fieldStrings = sortedFields.map(field => {
            let optionalMarker = field.required ? "" : "?";
            let fieldType;
            if (field.required) {
              fieldType = field.type_;
            } else {
              let innerType = field.type_;
              fieldType = typeof innerType !== "object" || innerType.TAG !== "Option" ? innerType : innerType._0;
            }
            return "  " + field.name + optionalMarker + ": " + typeToString(fieldType) + ",";
          });
          return "{\n" + fieldStrings.join("\n") + "\n}";
        case "Variant" :
          let variantStrings = type_._0.map(v => v);
          return variantStrings.join(" | ");
        case "Reference" :
          return type_._0;
      }
    }
  };
  return "type " + toCamelCase(name) + " = " + typeToString(rescriptType);
}

export {
  extractedEnums,
  toCamelCase,
  mapPrimitiveType,
  generateVariantNames,
  generateVariantFromEnum,
  extractInlineEnum,
  convertPropertySchema,
  convertProperty,
  convertObjectSchema,
  convertSchema,
  generateExtractedEnumDefinitions,
  clearExtractedEnums,
  generateTypeDefinition,
}
/* No side effect */
